---
title: 优化
date: 2022-05-20 15:26:32
permalink: /pages/93d18b/
categories:
  - webpack
tags:
  - 
author: 
  name: 张广森
  link: https://github.com/mrzhang90
---
## 图片压缩
使用 file-loader 来处理图片文件，在此基础上，我们再添加一个 image-webpack-loader 来压缩图片文件
```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /.*\.(gif|png|jpe?g|svg|webp)$/i,
        use: [
          {
            loader: 'file-loader',
            options: {}
          },
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: { // 压缩 jpeg 的配置
                progressive: true,
                quality: 65
              },
              optipng: { // 使用 imagemin-optipng 压缩 png，enable: false 为关闭
                enabled: false,
              },
              pngquant: { // 使用 imagemin-pngquant 压缩 png
                quality: '65-90',
                speed: 4
              },
              gifsicle: { // 压缩 gif 的配置
                interlaced: false,
              },
              webp: { // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式
                quality: 75
              },
          },
        ],
      },
    ],
  },
}
```
image-webpack-loader 的压缩是使用 imagemin 提供的一系列图片压缩类库来处理的
## 使用 DataURL
以前流行的[CSS Sprtes](https://juejin.cn/post/6844903501890322440#heading-0)，受到 CSS background 限制，不利于维护

现在更方便的是直接将小图转为 base64，使用 DataURL引用它

可以使用url-loader 和 file-loader，配置一个指定大小的阈值，小于阈值则转为 base64，大于阈值则调用 file-loader 直接达到 file-loader
```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192, // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理
              fallback: 'file-loader',
            },
          },
        ],
      },
    ],
  },
}
```
## 代码压缩
html-webpack-plugin 生成 HTML 并且还可以做压缩
```js
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: 'assets/index.html', // 配置文件模板
      minify: { // 压缩 HTML 的配置
        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码
        minifyJS: true, // 压缩 HTML 中出现的 JS 代码
        collapseInlineTagWhitespace: true, 
        collapseWhitespace: true, // 和上一个配置配合，移除无用的空格和换行
      }
    }),
  ],
}
```
如上，使用 minify 字段配置就可以使用 HTML 压缩，这个插件是使用 html-minifier 来实现 HTML 代码压缩的，minify 下的配置项直接透传给 [html-minifier](https://github.com/kangax/html-minifier#options-quick-reference)，配置项参考 html-minifier 文档即可

对于 css 代码，需要在 postcss-loader 的基础上，使用 [**cssnano**](https://cssnano.co/)
```js
use: [
  'css-loader',
  {
    loader: 'postcss-loader',
    options: {
      plugins: () => [ // 返回 postcss 的插件列表
        require('cssnano')(), // 使用 cssnano
      ],
    },
  },
],
```
## 拆分代码文件
### mini-css-extract-plugin
  将 css 代码单独拆分出独立文件
### 分离公共部分
webpack 拆分 js 的简单例子：
```js
module.exports = {
  // ... webpack 配置

  optimization: {
    splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件
      name: 'common', // 给分离出来的 chunk 起个名字
    },
  },
}
```
如果是多页面，需要根据页面区分不同的 js 入口的话，那么在 html-webpack-plugin指定对应的 chunk：
```js
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      chunks: ['common', 'index'], // 这里要包括 common 部分和页面业务部分
    }),
  ]
}
```
#### splitChunks 配置项
optimization.splitChunks中有很多配置项

chunks 表示从哪些模块中抽取代码，可以设置 all/async/initial 三个值其中一个，分别表示 所有模块/异步加载的模块/同步加载的模块，或者也可以设置一个 function，用于过滤掉不需要抽取代码的模块，例如：
```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks (chunk) {
        // 排除 `my-excluded-chunk`
        return chunk.name !== 'my-excluded-chunk';
      }
    }
  }
};
```
#### 第三方类库
因为第三方类库升级频率相对较低，可以显示的配置公共类库
```js
module.exports = {
  optimization: {
    splitChunks: {
      cacheGroups: { 
        vendor: { // vendor 是我们第三方类库的公共代码的名称
          test: /react|angluar|lodash/, // 直接使用 test 来做路径匹配
          chunks: "initial",
          name: "vendor",
          enforce: true,
        },
      },
    },
  },
}

// 或者
module.exports = {
  optimization: {
    splitChunks: {
      cacheGroups: {
        vendor: {
          chunks: "initial",
          test: path.resolve(__dirname, "node_modules") // 路径在 node_modules 目录下的都作为公共部分
          name: "vendor", // 使用 vendor 入口作为公共部分
          enforce: true,
        },
      },
    },
  },
}
```
以上，第一种方法用 test做模块路径匹配，对应路径都作为第三方类库；第二种方法则是把 node_modules下的所有模块，都作为公共部分
### 按需加载
当页面中有一些代码不是每个用户都需要用到，那么可以将这些代码抽离出来，仅当用户真正用到时才加载。这个时候就需要 webpack 提供的一个优化功能-按需加载代码模块

```js
// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象
// 注释 webpackChunkName: "jquery" 可以用于指定 chunk 的名称，在输出文件时有用
import(/* webpackChunkName: "jquery" */ 'jquery').then(($) => { 
  console.log($);
});
```
