---
title: 插件
date: 2022-05-19 22:19:18
permalink: /pages/fa7309/
categories:
  - webpack
tags:
  - 
author: 
  name: 张广森
  link: https://github.com/mrzhang90
---
## DefinePlugin
DefinePlugin 是 webpack 内置的插件，用于配置在运行时可以使用的常量，可以使用webpack.DefinePlugin直接获取。
```js
module.exports = {
  // ...
  plugins: [
    new webpack.DefinePlugin({
      PRODUCTION: JSON.stringify(true), // const PRODUCTION = true
      VERSION: JSON.stringify('5fa3b9'), // const VERSION = '5fa3b9'
      BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = 'true'
      TWO: '1+1', // const TWO = 1 + 1,
      CONSTANTS: {
        APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = { APP_VERSION: '1.1.2' }
      }
    }),
  ],
}
``` 
以上的配置规则：
1. 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的'1+1',结果为 2；
2. 如果配置的值不是字符串，也不是对象字面量，那么改值会转成字符串，如 true，最终的结果是'true'；
3. 如果配置的值是对象字面量，那么该对象的所有 key会以相同的方式去定义

### 为什么 DefinePlugin 的配置用JSON.stringify
因为配置的值是字符串，就会被当成代码片段来执行，不是字符串的值会转成字符串

## [TerserPlugin](https://github.com/webpack-contrib/terser-webpack-plugin)
webpack mode为 production时会启用TerserPlugin来压缩 JS 代码
```js
module.exports = {
  // ...
  // TerserPlugin 的使用比较特别，需要配置在 optimization 字段中，属于构建代码优化的一部分
  optimization: {
    minimize: true, // 启用代码压缩
    minimizer: [new TerserPlugin({
      test: /\.js(\?.*)?$/i, // 只处理 .js 文件
      cache: true, // 启用缓存，可以加速压缩处理
    })], // 配置代码压缩工具
  },
}
```
在以前版本的 webpack是使用 UglifyWebpackPlugin来压缩 JS 代码，后来更换为 TerserPlugin，可以更好的处理新的 JS 语法
## IgnorePlugin
IgnorePlugin 和 DefinePlugin 都是 webpack 内置插件，可以直接 webpack.IgnorePlgin 获取

这个插件用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去。例如 moment.js 引用了大量的 I18n,导致打包出来的文件比较大，这时可以使用 IgnorePlugin 来忽略这些代码文件，配置如下：
```js
module.exports = {
  // ...
  plugins: [
    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)
  ]
}
```
IgnorePlugin 配置的参数有两个，第一个是匹配引入模块路径的正则表达式，第二个是匹配模块的对应上下文，即所在目录名

## webpack-bundle-analyzer
webpack-bundle-analyzer用于分析 webpack 构建打包的内容，用于查看各个模块的依赖关系和各个模块的代码内容多少，便于开发者做性能优化

webpack-bundle-analyzer是第三方的包，使用前需要安装，仅引入 plugin 即可，在构建时可以在浏览器查看分析结果：
```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  // ...
  plugins: [
    new BundleAnalyzerPlugin(),
  ],
}
```
**做优化时，可以先用 IgnorePlugin 来过滤部分大而无用的第三方模块，后续的代码加载优化再用到webpack-bundle-analyzer**

## html-webpack-plugin

将 HTML 引用路径和构建结果关联起来

## webpack-dashboard
webpack-dashboard 是一个花里胡哨的工具，它可以帮助你把 webpack 构建过程中的信息以一种更漂亮的方式展示出来，只需要两步：
1. ```js
    // 在配置中加入 webpack-dashboard 的 plugin
    const DashboardPlugin = require("webpack-dashboard/plugin");

    module.exports = {
      // ...
      plugins: [
        new DashboardPlugin(),
      ],
    }
    ```
2. 然后把我们启动 webpack-dev-server 的命令改为 webpack-dashboard -- webpack-dev-server，执行即可看到酷炫的构建界面了